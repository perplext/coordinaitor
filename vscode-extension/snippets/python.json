{
  "Multi-Agent Task": {
    "prefix": "mao-task",
    "body": [
      "# TODO: Multi-Agent Orchestrator Task",
      "# Title: ${1:Task Title}",
      "# Type: ${2|requirement,design,implementation,test,deployment,review|}",
      "# Priority: ${3|low,medium,high,critical|}",
      "# Description: ${4:Task description}",
      "# Requirements:",
      "# - ${5:Requirement 1}",
      "# - ${6:Requirement 2}",
      "",
      "${0:# Your code here}"
    ],
    "description": "Create a Multi-Agent Orchestrator task comment"
  },
  
  "MAO API Client": {
    "prefix": "mao-client",
    "body": [
      "import requests",
      "from typing import Dict, List, Optional",
      "",
      "class OrchestratorClient:",
      "    def __init__(self, base_url: str = '${1:http://localhost:3000/api}', api_key: Optional[str] = None):",
      "        self.base_url = base_url",
      "        self.session = requests.Session()",
      "        self.session.headers.update({",
      "            'Content-Type': 'application/json'",
      "        })",
      "        if api_key:",
      "            self.session.headers['Authorization'] = f'Bearer {api_key}'",
      "",
      "    def create_task(self, task: Dict) -> Dict:",
      "        response = self.session.post(f'{self.base_url}/tasks', json=task)",
      "        response.raise_for_status()",
      "        return response.json()",
      "",
      "    def execute_task(self, task_id: str) -> Dict:",
      "        response = self.session.post(f'{self.base_url}/tasks/{task_id}/execute')",
      "        response.raise_for_status()",
      "        return response.json()",
      "",
      "    def get_tasks(self) -> List[Dict]:",
      "        response = self.session.get(f'{self.base_url}/tasks')",
      "        response.raise_for_status()",
      "        return response.json()['tasks']",
      "",
      "    def search_knowledge(self, query: str, **filters) -> List[Dict]:",
      "        params = {'q': query, **filters}",
      "        response = self.session.get(f'{self.base_url}/knowledge/search', params=params)",
      "        response.raise_for_status()",
      "        return response.json()['entries']",
      "",
      "# Example usage:",
      "# client = OrchestratorClient(api_key='${2:your-api-key}')",
      "# tasks = client.get_tasks()"
    ],
    "description": "Create an API client for Multi-Agent Orchestrator"
  },

  "Knowledge Entry": {
    "prefix": "mao-knowledge",
    "body": [
      "\"\"\"",
      "Knowledge Entry: ${1:Title}",
      "Type: ${2|solution,pattern,snippet,documentation,error,best-practice|}",
      "Tags: ${3:tag1, tag2, tag3}",
      "Language: ${4:python}",
      "Difficulty: ${5|easy,medium,hard,expert|}",
      "",
      "Description:",
      "${6:Description of this knowledge entry}",
      "",
      "Usage:",
      "${7:How to use this code/pattern}",
      "\"\"\"",
      "",
      "${0:# Your code here}"
    ],
    "description": "Create a knowledge entry docstring structure"
  },

  "Async Task Function": {
    "prefix": "mao-async-task",
    "body": [
      "import asyncio",
      "from typing import Dict, Any",
      "",
      "async def ${1:task_name}() -> Dict[str, Any]:",
      "    \"\"\"",
      "    ${2:Task description}",
      "    ",
      "    Returns:",
      "        Dict containing success status and result/error",
      "    \"\"\"",
      "    try:",
      "        print(f'Task ${1:task_name} started')",
      "        ",
      "        ${0:# Your async code here}",
      "        ",
      "        print(f'Task ${1:task_name} completed successfully')",
      "        return {'success': True, 'result': ${3:result}}",
      "    except Exception as error:",
      "        print(f'Task ${1:task_name} failed: {error}')",
      "        return {'success': False, 'error': str(error)}"
    ],
    "description": "Create an async task function with error handling"
  },

  "MAO WebSocket Client": {
    "prefix": "mao-websocket",
    "body": [
      "import asyncio",
      "import websockets",
      "import json",
      "from typing import Callable, Optional",
      "",
      "class OrchestratorWebSocket:",
      "    def __init__(self, url: str = '${1:ws://localhost:3000}'):",
      "        self.url = url",
      "        self.websocket: Optional[websockets.WebSocketServerProtocol] = None",
      "        self.reconnect_interval = ${2:5}",
      "        self.running = False",
      "",
      "    async def connect(self):",
      "        \"\"\"Connect to the orchestrator WebSocket\"\"\"",
      "        try:",
      "            self.websocket = await websockets.connect(self.url)",
      "            print('Connected to orchestrator')",
      "            self.running = True",
      "            await self.listen()",
      "        except Exception as error:",
      "            print(f'Connection failed: {error}')",
      "            await asyncio.sleep(self.reconnect_interval)",
      "            if self.running:",
      "                await self.connect()",
      "",
      "    async def listen(self):",
      "        \"\"\"Listen for messages from the orchestrator\"\"\"",
      "        try:",
      "            async for message in self.websocket:",
      "                data = json.loads(message)",
      "                await self.handle_message(data)",
      "        except websockets.exceptions.ConnectionClosed:",
      "            print('Connection closed')",
      "            if self.running:",
      "                await asyncio.sleep(self.reconnect_interval)",
      "                await self.connect()",
      "",
      "    async def handle_message(self, message: dict):",
      "        \"\"\"Handle incoming messages\"\"\"",
      "        message_type = message.get('type')",
      "        if message_type == 'task:created':",
      "            print(f\"Task created: {message['data']['title']}\")",
      "        elif message_type == 'task:completed':",
      "            print(f\"Task completed: {message['data']['title']}\")",
      "        elif message_type == 'task:failed':",
      "            print(f\"Task failed: {message['data']['title']}\")",
      "        else:",
      "            print(f\"Unknown message type: {message_type}\")",
      "",
      "    async def disconnect(self):",
      "        \"\"\"Disconnect from the orchestrator\"\"\"",
      "        self.running = False",
      "        if self.websocket:",
      "            await self.websocket.close()",
      "",
      "# Example usage:",
      "# async def main():",
      "#     client = OrchestratorWebSocket()",
      "#     await client.connect()",
      "#",
      "# asyncio.run(main())"
    ],
    "description": "Create a WebSocket client for real-time orchestrator updates"
  },

  "Task Decorator": {
    "prefix": "mao-task-decorator",
    "body": [
      "from functools import wraps",
      "from typing import Callable, Any",
      "import time",
      "",
      "def orchestrator_task(title: str = '${1:Task Title}', task_type: str = '${2:implementation}', priority: str = '${3:medium}'):",
      "    \"\"\"",
      "    Decorator to mark functions as orchestrator tasks",
      "    \"\"\"",
      "    def decorator(func: Callable) -> Callable:",
      "        @wraps(func)",
      "        def wrapper(*args, **kwargs) -> Any:",
      "            start_time = time.time()",
      "            print(f'Starting task: {title}')",
      "            ",
      "            try:",
      "                result = func(*args, **kwargs)",
      "                duration = time.time() - start_time",
      "                print(f'Task completed: {title} ({duration:.2f}s)')",
      "                return result",
      "            except Exception as error:",
      "                duration = time.time() - start_time",
      "                print(f'Task failed: {title} ({duration:.2f}s) - {error}')",
      "                raise",
      "        ",
      "        # Add metadata to the function",
      "        wrapper._orchestrator_task = {",
      "            'title': title,",
      "            'type': task_type,",
      "            'priority': priority",
      "        }",
      "        ",
      "        return wrapper",
      "    return decorator",
      "",
      "# Example usage:",
      "# @orchestrator_task('Process Data', 'implementation', 'high')",
      "# def process_data(data):",
      "#     return processed_data"
    ],
    "description": "Create a task decorator for tracking function execution"
  }
}